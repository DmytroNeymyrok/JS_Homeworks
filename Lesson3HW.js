/* 1)  'number' + 3 + 3
Результат: number33
Унарний + та стрінг робить конкатинацію*/


/* 2)  null + 3
Результат:3
JS намагається привести null до числа, присвоює значення 0, потім вираховує 0+3=3 
*/


/* 3)  5 && "qwerty"
Результат: qwerty
Оператор іf повертає першу умову, якщо вона false, або другу, якщо перша true
5 — це truthy-значення (бо будь-яке ненульове число вважається істинним), тому повертається друге значення - qwerty
*/


/* 4)  +'40' + +'2' + "hillel";
Результат: 42hillel
+'40' - буде число 40
+'2' - буде число 2
40+2=42
число 42 + стрінга hilel = 42hilel
*/



/*5)  '10' - 5 === 6;
Результат: false
'10' - 5 = 5
5 === 6 Вони нерівні, тому false
*/


/* 6)  true + false 
Результат: 1
JS приводить булеан до числа, тому виходить 1+0=1
*/




/*7)  '4px' - 3
Результат: NaN
Cтрінг мінус число дорівнює NaN
*/




/*8)  '4' - 3
Результат:1
Стрінгу '4' приводить до числа 4
4-3=1
*/




/*9)  '6' + 3 ** 0;
Результат:61
Спочатку виконується 3 ** 0, дорівнює 1 (правоасоціативний оператор)
Потім виконується конкатинація '6' + 1. 61
*/




/*10)  12 / '6'
Результат:2
JS перетворить стрінгу '6' в число 6, а потів виконає 12/6=2
*/



/*11)  '10' + (5 === 6);
Результат:10false
(5 === 6) буде false, далі виконується конкатинація стрінги '10' та false
*/



/*12)  null == ''
Результат:false
Важливо врахувати, що null дорівнює тільки undefined при нестрогому порівнянні та
null не приводиться до числа, рядка або false при порівнянні через == (В останньому невпевнений, чат GPT та ментор дають різну інформацію)
Пуста строка '' буде приведена до false, однак null не дорівнює false.
*/



/*13)  3 ** (9 / 3);
Результат: 27
Спочатку виконається розрахунок 9/3=3
Далі 3 в третьому ступені = 27
*/



/*14)  !!'false' == !!'true'
Результат: true
!'false' та !'true' приводить текст до булевого типу та інвертує його. Непорожній стрінг дасть true, при інверсії отримаємо
false для обох виразів
Другий ! знов інвертує це значення, в результаті отримаємо true==true
Оскільки нерівність нестрога, то отримаємо true
*/



/*15)  0 || '0' && 1
Результат: 1
Розберу вираз по частинам. Оператор && має більший пріоритет, ніж ||, тому першим виконується вираз 
'0' && 1
Оператор повертає останнє truthy-значення, якщо обидва операнди truthy.
Стрінга '0' та цифра 1 - це truthy, тому повертається 1.
Далі виконується вираз 0 || 1
Оператор || повертає перше truthy значення, в данному випадку це 1.
*/



/*16)  (+null == false) < 1;
Результат: false
Спочатку виконується +null == false. +null приводиться до 0, false приводиться до 0. Нестроге порівняння 0==0 віддає true.
Далі true < 1. true приводиться до 1.
1 < 1. Відповідь false
*/




/*17)  false && true || true
Результат: true
Спочатку виконується false && true. Повертає false, оскільки не 2 вирази truthy.
Далі false || true. Повертається true, оскільки || повертає перше truthy.
*/





/*18)  false && (false || true);
Результат: false
Спочатку виконується false || true. Аналогічно попередньому завданню повертається true.
Далі false && true. Поверне false, оскільки false не truthy
*/




/*19)  (+null == false) < 1 ** 5; 
Результат:
Спочатку виконується +null == false
0 == false     буде true
Далі 1 ** 5, осrільки це правоасоціативний оператор і піднесення до степеня має вищий пріоритет. Буде 1
Далі true < 1. true буде приведено до 1.
1 < 1
Відповідь false
*/
 // додав строку для створення коміту